@page "/spin"
@using BloodSuckersSlot.Web.Models
@using BloodSuckersSlot.Web.Services
@using global::Shared
@using System.Text.Json
@inject HttpClient Http
@inject IJSRuntime JS
@inject IConfiguration Configuration

<PageTitle>Spin Page</PageTitle>

<div class="container-fluid">
    <div class="row">
        <!-- Main Spin Area -->
        <div class="col-md-8">
            <div class="card">
                <div class="card-header">
                    <h3>Slot Machine Spin</h3>
                </div>
                <div class="card-body">
                    <!-- Loading Status -->
                    @if (isLoadingReelSets)
                    {
                        <div class="text-center mb-4">
                            <div class="alert alert-info">
                                <h5>Loading Reel Sets...</h5>
                                <div class="progress mb-2">
                                    <div class="progress-bar progress-bar-striped progress-bar-animated" 
                                         role="progressbar" 
                                         style="width: @(loadingProgress * 100)%" 
                                         aria-valuenow="@(loadingProgress * 100)" 
                                         aria-valuemin="0" aria-valuemax="100">
                                        @((loadingProgress * 100).ToString("F1"))%
                                    </div>
                                </div>
                            </div>
                        </div>
                    }

                    <!-- Bet Controls -->
                    <div class="row mb-4">
                        <div class="col-md-6">
                            <div class="form-group">
                                <label for="coinValue">Coin Value: $@coinValue.ToString("F2")</label>
                                <input type="range" id="coinValue" class="form-range" 
                                       min="@minCoinValue" max="@maxCoinValue" step="0.01" 
                                       value="@coinValue" @onchange="OnCoinValueChanged" />
                                <div class="d-flex justify-content-between">
                                    <small>$@minCoinValue.ToString("F2")</small>
                                    <small>$@maxCoinValue.ToString("F2")</small>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="form-group">
                                <label for="level">Level: @level</label>
                                <input type="range" id="level" class="form-range" 
                                       min="1" max="@maxLevel" step="1" 
                                       value="@level" @onchange="OnLevelChanged" />
                                <div class="d-flex justify-content-between">
                                    <small>1</small>
                                    <small>@maxLevel</small>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Bet Information -->
                    <div class="row mb-4">
                        <div class="col-md-4">
                            <div class="card">
                                <div class="card-body text-center">
                                    <h6>Bet (Coins)</h6>
                                    <h4>@betInCoins</h4>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-4">
                            <div class="card">
                                <div class="card-body text-center">
                                    <h6>Total Bet</h6>
                                    <h4>@totalBet.ToString("C")</h4>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-4">
                            <div class="card">
                                <div class="card-body text-center">
                                    <h6>Last Win</h6>
                                    <h4>@lastWin.ToString("C")</h4>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Spin Button -->
                    <div class="text-center mb-4">
                        <button class="btn btn-primary btn-lg" @onclick="PerformSpin" 
                                disabled="@(isSpinning || isLoadingReelSets || !reelSetsLoaded)">
                            @if (isSpinning)
                            {
                                <span class="spinner-border spinner-border-sm me-2" role="status"></span>
                                <span>Spinning...</span>
                            }
                            else if (isLoadingReelSets)
                            {
                                <span>‚è≥ Loading...</span>
                            }
                            else if (!reelSetsLoaded)
                            {
                                <span>‚è≥ Waiting...</span>
                            }
                            else
                            {
                                <span>üé∞ SPIN</span>
                            }
                        </button>
                    </div>

                    <!-- Grid Display -->
                    @if (currentGrid != null)
                    {
                                                     <div class="text-center mb-4">
                                 <h5>Spin Result</h5>
                                 @if (winningLines != null && winningLines.Count > 0)
                                 {
                                 }
                            <div class="slot-grid position-relative">
                                @for (int row = 0; row < 3; row++)
                                {
                                    <div class="slot-row">
                                        @for (int col = 0; col < 5; col++)
                                        {
                                            <div class="slot-symbol @GetSymbolClass(currentGrid[col][row]) position-relative">
                                                <img src="/images/symbols/@(currentGrid[col][row].ToLower()).png" 
                                                     alt="@currentGrid[col][row]" 
                                                     class="symbol-image" />
                                                @if (IsWinningPosition(col, row))
                                                {
                                                    <div class="winning-highlight"></div>
                                                }
                                            </div>
                                        }
                                    </div>
                                }
                                
                                                                 <!-- Winning Lines Overlay -->
                                 @if (winningLines != null && winningLines.Count > 0)
                                 {
                                     <div class="winning-lines-overlay">
                                         @foreach (var line in winningLines)
                                         {
                                             <!-- Full payline path (dotted line) -->
                                             <svg class="payline-path" viewBox="0 0 500 180">
                                                 <path d="@CreateSvgPath(line.FullPaylinePath)" stroke="gray" stroke-width="2" fill="none" 
                                                       stroke-dasharray="3,3" opacity="0.5" />
                                             </svg>
                                             
                                             <!-- Winning positions path (solid line) -->
                                             <svg class="winning-line" viewBox="0 0 500 180">
                                                 <path d="@line.Path" stroke="yellow" stroke-width="3" fill="none" 
                                                       stroke-dasharray="5,5" opacity="0.8" />
                                             </svg>
                                         }
                                     </div>
                                 }
                            </div>
                        </div>

                        <!-- Win Information -->
                        @if (lastSpinResult != null)
                        {
                            <div class="win-breakdown">
                                <h6>üí∞ Win Breakdown:</h6>
                                <p><strong>Total Win:</strong> @lastSpinResult.TotalWin</p>
                                <p><strong>Line Win:</strong> @lastSpinResult.LineWin</p>
                                <p><strong>Wild Win:</strong> @lastSpinResult.WildWin</p>
                                <p><strong>Scatter Win:</strong> @lastSpinResult.ScatterWin</p>
                                @if (lastSpinResult.BonusWin > 0)
                                {
                                    <p><strong>üéÅ Bonus Win:</strong> <span class="badge bg-danger">@lastSpinResult.BonusWin coins</span></p>
                                }
                                @if (lastSpinResult.BonusTriggered)
                                {
                                    <div class="bonus-trigger">
                                        <p><strong>üé∞ COFFIN SELECTION BONUS GAME!</strong></p>
                                        <p><em>You triggered the BloodSuckers coffin selection bonus!</em></p>
                                        @if (!string.IsNullOrEmpty(lastSpinResult.BonusLog))
                                        {
                                            <p><strong>Trigger:</strong> <em>@lastSpinResult.BonusLog</em></p>
                                        }
                                        @if (lastSpinResult.BonusWin > 0)
                                        {
                                            <p><strong>üéÅ Total Bonus Win:</strong> <span class="badge bg-danger">@lastSpinResult.BonusWin coins</span></p>
                                            <p><small><em>You selected 3 coffins and revealed their hidden prizes!</em></small></p>
                                        }
                                    </div>
                                }
                            </div>

                            <!-- Free Spin Information -->
                            <div class="free-spin-info">
                                <h6>üé∞ Spin Status:</h6>
                                <p><strong>Spin Type:</strong> 
                                    <span class="@(lastSpinResult.IsFreeSpin ? "free-spin-badge" : "paid-spin-badge")">@lastSpinResult.SpinType</span>
                                </p>
                                <p><strong>Free Spins Remaining:</strong> <span class="badge bg-success">@lastSpinResult.FreeSpinsRemaining</span></p>
                                @if (lastSpinResult.ScatterCount > 0)
                                {
                                    <p><strong>Scatters This Spin:</strong> <span class="badge bg-warning">@lastSpinResult.ScatterCount</span></p>
                                }
                            </div>

                            <!-- Winning Line Calculations for Testing -->
                            @if (winningLines != null && winningLines.Count > 0)
                            {
                                <div class="winning-line-calculation">
                                    <h6>üßÆ Winning Line Calculations (Testing):</h6>
                                    @foreach (var line in winningLines)
                                    {
                                        <div class="winning-line-detail">
                                            <p><strong>Symbol:</strong> 
                                                <img src="/images/symbols/@(GetSymbolImageName(line.Symbol))" alt="@line.Symbol" style="width: 30px; height: 30px; vertical-align: middle; margin-right: 5px;" />
                                                @line.Symbol
                                            </p>
                                            <p><strong>Count:</strong> @line.Count</p>
                                            <p><strong>Win Amount:</strong> @line.WinAmount</p>
                                            <p><strong>Payline Type:</strong> @line.PaylineType</p>
                                            <p><strong>Payline Index:</strong> @(line.PaylineIndex >= 0 ? $"#{line.PaylineIndex + 1}" : "N/A")</p>
                                            <p><strong>Winning Positions:</strong> @string.Join(", ", line.Positions.Select(p => $"({p.Col},{p.Row})"))</p>
                                            <p><strong>Full Payline Path:</strong> @string.Join(", ", line.FullPaylinePath.Select(p => $"({p.Col},{p.Row})"))</p>
                                            <p><strong>SVG Path:</strong> <code>@line.Path</code></p>
                                        </div>
                                    }
                                </div>
                            }
                        }

                        <!-- Chosen Reel Set Info -->
                        @if (chosenReelSet != null)
                        {
                            <div class="alert alert-secondary">
                                <h6>Selected Reel Set:</h6>
                                <p><strong>Name:</strong> @chosenReelSet.Name</p>
                                <p><strong>Expected RTP:</strong> @(chosenReelSet.ExpectedRtp.ToString("P2"))</p>
                                <p><strong>Estimated Hit Rate:</strong> @(chosenReelSet.EstimatedHitRate.ToString("P2"))</p>
                            </div>
                        }
                    }
                </div>
            </div>
        </div>

        <!-- Charts Sidebar -->
        <div class="col-md-4">
            <div class="card mb-3">
                <div class="card-header">
                    <h5>RTP Chart</h5>
                </div>
                <div class="card-body">
                    <div style="height: 200px;">
                        <canvas id="rtpChartSmall" width="300" height="200"></canvas>
                    </div>
                </div>
            </div>

            <div class="card">
                <div class="card-header">
                    <h5>Hit Rate Chart</h5>
                </div>
                <div class="card-body">
                    <div style="height: 200px;">
                        <canvas id="hitRateChartSmall" width="300" height="200"></canvas>
                    </div>
                </div>
            </div>

            <!-- Current Stats -->
            <div class="card mt-3">
                <div class="card-header">
                    <h5>Current Stats</h5>
                </div>
                <div class="card-body">
                    @{
                        var rtpTarget = Configuration.GetValue<double>("RtpTarget", 0.88);
                    }
                    <p><strong>Current RTP:</strong> <span class="@(currentRtp >= rtpTarget ? "text-success" : "text-danger")">@(currentRtp.ToString("P2"))</span></p>
                    <p><strong>Current Hit Rate:</strong> <span class="@(currentHitRate >= 0.35 ? "text-success" : "text-danger")">@(currentHitRate.ToString("P2"))</span></p>
                    <p><strong>Total Spins:</strong> @totalSpins</p>
                </div>
            </div>

            <!-- Session Statistics -->
            @if (lastSpinResult != null)
            {
                <div class="card mt-3">
                    <div class="card-header">
                        <h5>üé∞ Session Statistics</h5>
                    </div>
                    <div class="card-body">
                        <p><strong>Current Spin Type:</strong> 
                            <span class="badge @(lastSpinResult.IsFreeSpin ? "bg-success" : "bg-primary")">@lastSpinResult.SpinType</span>
                        </p>
                        <p><strong>Free Spins Remaining:</strong> <span class="badge bg-success">@lastSpinResult.FreeSpinsRemaining</span></p>
                        <p><strong>Free Spins Awarded This Session:</strong> <span class="badge bg-info">@lastSpinResult.FreeSpinsAwarded</span></p>
                        <p><strong>Total Free Spins Awarded:</strong> <span class="badge bg-warning">@lastSpinResult.TotalFreeSpinsAwarded</span></p>
                        <p><strong>Total Bonuses Triggered:</strong> <span class="badge bg-danger">@lastSpinResult.TotalBonusesTriggered</span></p>
                        @if (lastSpinResult.ScatterCount > 0)
                        {
                            <p><strong>Last Spin Scatters:</strong> <span class="badge bg-warning">@lastSpinResult.ScatterCount</span></p>
                        }
                        @if (lastSpinResult.BonusWin > 0)
                        {
                            <p><strong>Last Bonus Win:</strong> <span class="badge bg-danger">@lastSpinResult.BonusWin coins</span></p>
                            <p><small><em>üé∞ Coffin Selection Bonus Game</em></small></p>
                        }
                        @if (lastSpinResult.BonusTriggered)
                        {
                            <p><strong>üé∞ Bonus Game Status:</strong> <span class="badge bg-success">ACTIVE</span></p>
                        }
                    </div>
                </div>
            }
        </div>
    </div>
</div>

<style>
    .slot-grid {
        display: inline-block;
        border: 2px solid #333;
        background: #1a1a1a;
        padding: 10px;
        border-radius: 10px;
    }

    .slot-row {
        display: flex;
        margin-bottom: 5px;
    }

    .slot-row:last-child {
        margin-bottom: 0;
    }

    .slot-symbol {
        width: 80px;
        height: 60px;
        margin: 0 2px;
        border: 1px solid #444;
        border-radius: 5px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #2a2a2a;
        position: relative;
        overflow: hidden;
    }

    .symbol-image {
        width: 100%;
        height: 100%;
        object-fit: contain;
        border-radius: 3px;
    }

    .winning-highlight {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 255, 0, 0.3);
        border: 2px solid yellow;
        border-radius: 3px;
        animation: pulse 1s infinite;
    }

    @@keyframes pulse {
        0% { opacity: 0.3; }
        50% { opacity: 0.7; }
        100% { opacity: 0.3; }
    }

    .winning-lines-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        pointer-events: none;
        z-index: 10;
    }

         .winning-line {
         position: absolute;
         top: 0;
         left: 0;
         width: 100%;
         height: 100%;
     }
     
     .payline-path {
         position: absolute;
         top: 0;
         left: 0;
         width: 100%;
         height: 100%;
         z-index: 5;
     }

    .scatter { /* background: linear-gradient(45deg, #ffd700, #ffed4e); */ }
    .wild { /* background: linear-gradient(45deg, #00bfff, #87ceeb); */ }
    .bonus { /* background: linear-gradient(45deg, #ff4500, #ff6347); */ }
    .high-pay { /* background: linear-gradient(45deg, #32cd32, #90ee90); */ }

    .free-spin-badge {
        background: linear-gradient(45deg, #28a745, #20c997);
        color: white;
        padding: 0.25rem 0.5rem;
        border-radius: 0.25rem;
        font-weight: bold;
    }

    .paid-spin-badge {
        background: linear-gradient(45deg, #007bff, #0056b3);
        color: white;
        padding: 0.25rem 0.5rem;
        border-radius: 0.25rem;
        font-weight: bold;
    }

    .bonus-trigger {
        background: linear-gradient(45deg, #ff4500, #ff6347);
        color: white;
        padding: 0.5rem;
        border-radius: 0.5rem;
        margin: 0.5rem 0;
        animation: pulse 2s infinite;
        border: 2px solid #ff4500;
        box-shadow: 0 4px 8px rgba(255, 69, 0, 0.3);
    }

    .bonus-trigger p {
        margin-bottom: 0.5rem;
    }

    .bonus-trigger strong {
        color: #fff;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
    }

    .bonus-trigger em {
        color: #ffe4e1;
        font-style: italic;
    }

    .bonus-trigger small {
        color: #ffe4e1;
        font-size: 0.875rem;
    }

    /* Coffin-themed bonus styling */
    .bonus-trigger::before {
        content: "‚ö∞Ô∏è";
        font-size: 1.5rem;
        margin-right: 0.5rem;
        display: inline-block;
        animation: coffinShake 1s ease-in-out infinite;
    }

    @@keyframes coffinShake {
        0%, 100% { transform: rotate(0deg); }
        25% { transform: rotate(-5deg); }
        75% { transform: rotate(5deg); }
    }

    .free-spin-info {
        background: linear-gradient(45deg, #ffc107, #ffdb4d);
        border: 2px solid #ffc107;
        border-radius: 0.5rem;
        padding: 1rem;
        margin: 0.5rem 0;
    }

    .win-breakdown {
        background: linear-gradient(45deg, #17a2b8, #20c997);
        border: 2px solid #17a2b8;
        border-radius: 0.5rem;
        padding: 1rem;
        margin: 0.5rem 0;
    }

    .winning-line-calculation {
        background: linear-gradient(45deg, #6f42c1, #8e44ad);
        border: 2px solid #6f42c1;
        border-radius: 0.5rem;
        padding: 1rem;
        margin: 0.5rem 0;
        color: white;
    }

    .winning-line-detail {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 0.25rem;
        padding: 0.5rem;
        margin: 0.25rem 0;
    }

         .winning-line-detail code {
         background: rgba(0, 0, 0, 0.3);
         padding: 0.25rem 0.5rem;
         border-radius: 0.25rem;
         font-size: 0.875rem;
     }
     
     .payline-legend {
         background: rgba(0, 0, 0, 0.1);
         padding: 0.5rem;
         border-radius: 0.25rem;
         border: 1px solid rgba(255, 255, 255, 0.2);
     }

    /* Progress bar enhancements */
    .progress {
        height: 1.5rem;
        background-color: #2c3e50;
        border-radius: 0.75rem;
        overflow: hidden;
        box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        border: 1px solid #34495e;
    }

    .progress-bar {
        background: linear-gradient(45deg, #3498db, #2980b9, #1f618d);
        background-size: 200% 200%;
        animation: gradientShift 2s ease infinite;
        transition: width 0.3s ease-in-out;
        border-radius: 0.75rem;
        font-weight: bold;
        font-size: 0.875rem;
        line-height: 1.5rem;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
        color: white;
        border: 1px solid #21618c;
    }

    .progress-bar-striped {
        background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.25) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.25) 50%, rgba(255, 255, 255, 0.25) 75%, transparent 75%, transparent);
        background-size: 1rem 1rem;
    }

    .progress-bar-animated {
        animation: progressBarAnimation 1s linear infinite, gradientShift 2s ease infinite;
    }

    @@keyframes progressBarAnimation {
        0% { background-position: 1rem 0; }
        100% { background-position: 0 0; }
    }

    @@keyframes gradientShift {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
    }

    /* Loading alert enhancements */
    .alert-info {
        background: linear-gradient(135deg, #3498db, #2980b9);
        border: 2px solid #21618c;
        border-radius: 0.75rem;
        box-shadow: 0 4px 8px rgba(52, 152, 219, 0.3);
        color: white;
    }

    .alert-info h5 {
        color: white;
        font-weight: bold;
        margin-bottom: 1rem;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
    }
</style>

@code {
    private bool isSpinning = false;
    private bool isLoadingReelSets = true;
    private bool reelSetsLoaded = false;
    private int totalReelSets = 0;
    private int loadedReelSets = 0;
    private double loadingProgress = 0.0;
    private string[][]? currentGrid;
    private SpinResult? lastSpinResult;
    private dynamic? chosenReelSet;
    private double currentRtp = 0.0;
    private double currentHitRate = 0.0;
    private int totalSpins = 0;

    // Betting System Variables
    private int baseBetPerLevel = 25;
    private int level = 1;
    private int maxLevel = 4;
    private decimal coinValue = 0.10m;
    private decimal minCoinValue = 0.01m;
    private decimal maxCoinValue = 0.50m;
    private int betInCoins = 25;
    private decimal totalBet = 2.50m;
    private decimal lastWin = 0.00m;

    // Chart data
    private List<string> rtpLabels = new();
    private List<double> rtpData = new();
    private List<double> rtpTargetData = new();
    private List<string> hitRateLabels = new();
    private List<double> hitRateData = new();
    private List<double> hitRateTargetData = new();
    private bool chartsInitialized = false;
    
    // Winning lines and positions
    private List<WinningLine> winningLines = new();
    private HashSet<(int col, int row)> winningPositions = new();

    // API winning line data structure
    public class ApiWinningLine
    {
        public List<Position> Positions { get; set; } = new();
        public string Symbol { get; set; } = "";
        public int Count { get; set; }
        public double WinAmount { get; set; }
        public string PaylineType { get; set; } = "";
        public string SvgPath { get; set; } = "";
        public int PaylineIndex { get; set; } = -1;
        public List<Position> FullPaylinePath { get; set; } = new();
    }

    public class Position
    {
        public int Col { get; set; }
        public int Row { get; set; }
    }

    // Frontend winning line data structure
    public class WinningLine
    {
        public string Path { get; set; } = "";
        public double WinAmount { get; set; }
        public string Symbol { get; set; } = "";
        public int Count { get; set; }
        public string PaylineType { get; set; } = "";
        public int PaylineIndex { get; set; } = -1;
        public List<Position> Positions { get; set; } = new();
        public List<Position> FullPaylinePath { get; set; } = new();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JS.InvokeVoidAsync("console.log", "üîÑ Spin page loaded - triggering reel set reload...");
            
            // Load betting system configuration
            LoadBettingConfiguration();
            
            // Trigger reel set reload on page load (this will handle progress polling internally)
            await TriggerReelSetReload();
            
            await InitializeCharts();
            chartsInitialized = true;
            
            // Force chart initialization after a delay to ensure DOM is ready
            await Task.Delay(500);
            await RenderCharts();
        }
    }

    private void LoadBettingConfiguration()
    {
        baseBetPerLevel = Configuration.GetValue<int>("BaseBetPerLevel", 25);
        level = Configuration.GetValue<int>("DefaultLevel", 1);
        maxLevel = Configuration.GetValue<int>("MaxLevel", 4);
        coinValue = Configuration.GetValue<decimal>("DefaultCoinValue", 0.10m);
        minCoinValue = Configuration.GetValue<decimal>("MinCoinValue", 0.01m);
        maxCoinValue = Configuration.GetValue<decimal>("MaxCoinValue", 0.50m);
        
        UpdateBetCalculations();
    }

    private void UpdateBetCalculations()
    {
        betInCoins = baseBetPerLevel * level;
        totalBet = betInCoins * coinValue;
        JS.InvokeVoidAsync("console.log", $"üîÑ Bet calculations updated - Level: {level}, CoinValue: {coinValue:C}, BetInCoins: {betInCoins}, TotalBet: {totalBet:C}");
    }

    private void OnCoinValueChanged(ChangeEventArgs e)
    {
        if (decimal.TryParse(e.Value?.ToString(), out decimal newValue))
        {
            coinValue = Math.Max(minCoinValue, Math.Min(maxCoinValue, newValue));
            UpdateBetCalculations();
            StateHasChanged();
        }
    }

    private void OnLevelChanged(ChangeEventArgs e)
    {
        if (int.TryParse(e.Value?.ToString(), out int newValue))
        {
            level = Math.Max(1, Math.Min(maxLevel, newValue));
            UpdateBetCalculations();
            StateHasChanged();
        }
    }

    private bool IsWinningPosition(int col, int row)
    {
        return winningPositions.Contains((col, row));
    }

    private void ProcessWinningLinesFromApi(List<ApiWinningLine> apiWinningLines)
    {
        winningLines.Clear();
        winningPositions.Clear();
        
        if (apiWinningLines == null || apiWinningLines.Count == 0)
        {
            JS.InvokeVoidAsync("console.log", "No winning lines from API");
            return;
        }

        JS.InvokeVoidAsync("console.log", $"Processing {apiWinningLines.Count} winning lines from API");
        
        foreach (var apiLine in apiWinningLines)
        {
            JS.InvokeVoidAsync("console.log", $"Processing API line - Symbol: '{apiLine.Symbol}', Count: {apiLine.Count}, WinAmount: {apiLine.WinAmount}, SvgPath: '{apiLine.SvgPath}', Positions: {apiLine.Positions.Count}");
            
            // Add positions to winning positions set
            foreach (var pos in apiLine.Positions)
            {
                winningPositions.Add((pos.Col, pos.Row));
                JS.InvokeVoidAsync("console.log", $"Added winning position: ({pos.Col}, {pos.Row})");
            }
            
            // Create frontend winning line
            var frontendLine = new WinningLine
            {
                Path = CreateSvgPath(apiLine.Positions), // Winning positions path
                WinAmount = apiLine.WinAmount,
                Symbol = apiLine.Symbol,
                Count = apiLine.Count,
                PaylineType = apiLine.PaylineType,
                PaylineIndex = apiLine.PaylineIndex,
                Positions = apiLine.Positions,
                FullPaylinePath = apiLine.FullPaylinePath
            };
            
            winningLines.Add(frontendLine);
            
            JS.InvokeVoidAsync("console.log", $"Created frontend winning line: Symbol='{frontendLine.Symbol}', Count={frontendLine.Count}, WinAmount={frontendLine.WinAmount}, Path='{frontendLine.Path}', Positions={frontendLine.Positions.Count}");
        }
        
        JS.InvokeVoidAsync("console.log", $"Final result: {winningLines.Count} lines, {winningPositions.Count} positions");
    }

    private async Task CheckLoadingStatus()
    {
        try
        {
            var apiBaseUrl = Configuration["ApiBaseUrl"] ?? "http://localhost:5000";
            var apiUrl = $"{apiBaseUrl}/api/spin/health";
            await JS.InvokeVoidAsync("console.log", $"Checking API health: {apiUrl}");
            
            var response = await Http.GetAsync(apiUrl);
            await JS.InvokeVoidAsync("console.log", $"Health check response: {response.StatusCode}");
            
            if (response.IsSuccessStatusCode)
            {
                var json = await response.Content.ReadAsStringAsync();
                await JS.InvokeVoidAsync("console.log", $"Health check JSON: {json}");
                
                using var doc = JsonDocument.Parse(json);
                var root = doc.RootElement;

                // With lazy loading, we don't need to wait for reel sets to load
                // The API will load them on-demand when spinning
                isLoadingReelSets = false;
                reelSetsLoaded = true;
                totalReelSets = 0; // Not applicable with lazy loading
                loadedReelSets = 0; // Not applicable with lazy loading
                loadingProgress = 1.0; // 100% - ready to spin

                await JS.InvokeVoidAsync("console.log", $"‚úÖ API ready for spinning - Lazy loading enabled");
                
                // Force UI update
                StateHasChanged();
            }
            else
            {
                await JS.InvokeVoidAsync("console.error", $"‚ùå API health check failed: {response.StatusCode}");
                isLoadingReelSets = false;
                reelSetsLoaded = false;
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            await JS.InvokeVoidAsync("console.error", "Error checking API health:", ex.Message);
            isLoadingReelSets = false;
            reelSetsLoaded = false;
            StateHasChanged();
        }
    }

    private async Task TriggerReelSetReload()
    {
        try
        {
            await JS.InvokeVoidAsync("console.log", "üîÑ Checking API readiness for lazy loading...");
            
            // Test if API is accessible using the health endpoint
            var apiBaseUrl = Configuration["ApiBaseUrl"] ?? "http://localhost:5000";
            var testUrl = $"{apiBaseUrl}/api/spin/health";
            await JS.InvokeVoidAsync("console.log", $"Testing API connectivity: {testUrl}");
            
            var testResponse = await Http.GetAsync(testUrl);
            await JS.InvokeVoidAsync("console.log", $"Health check response status: {testResponse.StatusCode}");
            
            if (testResponse.IsSuccessStatusCode)
            {
                var testJson = await testResponse.Content.ReadAsStringAsync();
                await JS.InvokeVoidAsync("console.log", $"‚úÖ API health check successful: {testJson}");
                
                // With lazy loading, we don't need to trigger any reload
                // Just check that the API is healthy and ready
                await CheckLoadingStatus();
            }
            else
            {
                await JS.InvokeVoidAsync("console.error", "‚ùå API health check failed - API might not be running");
                isLoadingReelSets = false;
                reelSetsLoaded = false;
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            await JS.InvokeVoidAsync("console.error", "Error checking API readiness:", ex.Message);
            await JS.InvokeVoidAsync("console.error", "Exception details:", ex.ToString());
            
            // Reset loading state on error
            isLoadingReelSets = false;
            reelSetsLoaded = false;
            StateHasChanged();
        }
    }

    private async Task PerformSpin()
    {
        if (isSpinning) return;

        isSpinning = true;
        StateHasChanged();

        try
        {
            var apiBaseUrl = Configuration["ApiBaseUrl"] ?? "http://localhost:5000";
            var apiUrl = $"{apiBaseUrl}/api/spin/spin";
            await JS.InvokeVoidAsync("console.log", $"Calling API: {apiUrl}");
            
            var response = await Http.PostAsJsonAsync(apiUrl, new { 
                BetAmount = betInCoins, // Legacy support
                Level = level,
                CoinValue = coinValue
            });
            
            await JS.InvokeVoidAsync("console.log", $"üì§ Sent to API - Level: {level}, CoinValue: {coinValue:C}, BetInCoins: {betInCoins}");
            await JS.InvokeVoidAsync("console.log", $"API Response Status: {response.StatusCode}");
            
            if (response.IsSuccessStatusCode)
            {
                var json = await response.Content.ReadAsStringAsync();
                await JS.InvokeVoidAsync("console.log", $"API Response: {json}");
                
                using var doc = JsonDocument.Parse(json);
                var root = doc.RootElement;

                // Parse grid
                var grid = root.GetProperty("grid");
                currentGrid = new string[5][];
                int colIdx = 0;
                foreach (var col in grid.EnumerateArray())
                {
                    var colArr = new string[3];
                    int rowIdx = 0;
                    foreach (var s in col.EnumerateArray())
                    {
                        colArr[rowIdx++] = s.GetString() ?? "";
                    }
                    currentGrid[colIdx++] = colArr;
                }

                // Parse monetary payout
                decimal monetaryPayout = 0.00m;
                if (root.TryGetProperty("monetaryPayout", out var monetaryPayoutProp))
                {
                    monetaryPayout = monetaryPayoutProp.GetDecimal();
                    lastWin = monetaryPayout;
                    await JS.InvokeVoidAsync("console.log", $"‚úÖ Found monetaryPayout: {monetaryPayout:C}");
                }
                else
                {
                    await JS.InvokeVoidAsync("console.log", "‚ùå No monetaryPayout found in API response");
                }

                // Debug: Check if result.TotalWin is available
                if (root.TryGetProperty("result", out var resultProp))
                {
                    if (resultProp.TryGetProperty("totalWin", out var totalWinProp))
                    {
                        var totalWin = totalWinProp.GetDouble();
                        await JS.InvokeVoidAsync("console.log", $"‚úÖ Found result.totalWin: {totalWin} coins");
                    }
                    else
                    {
                        await JS.InvokeVoidAsync("console.log", "‚ùå No result.totalWin found in API response");
                    }
                }

                // Parse spin result
                var spinResult = root.GetProperty("result");
                lastSpinResult = new SpinResult
                {
                    TotalWin = spinResult.GetProperty("totalWin").GetDouble(),
                    LineWin = spinResult.GetProperty("lineWin").GetDouble(),
                    WildWin = spinResult.GetProperty("wildWin").GetDouble(),
                    ScatterWin = spinResult.GetProperty("scatterWin").GetDouble(),
                    BonusWin = spinResult.GetProperty("bonusWin").GetDouble(),
                    ScatterCount = spinResult.GetProperty("scatterCount").GetInt32(),
                    BonusLog = spinResult.GetProperty("bonusLog").GetString() ?? "",
                    IsFreeSpin = spinResult.GetProperty("isFreeSpin").GetBoolean(),
                    BonusTriggered = spinResult.GetProperty("bonusTriggered").GetBoolean(),
                    
                    // Parse new free spin and bonus tracking fields
                    FreeSpinsRemaining = spinResult.GetProperty("freeSpinsRemaining").GetInt32(),
                    FreeSpinsAwarded = spinResult.GetProperty("freeSpinsAwarded").GetInt32(),
                    TotalFreeSpinsAwarded = spinResult.GetProperty("totalFreeSpinsAwarded").GetInt32(),
                    TotalBonusesTriggered = spinResult.GetProperty("totalBonusesTriggered").GetInt32(),
                    SpinType = spinResult.GetProperty("spinType").GetString() ?? ""
                };

                // Debug logging for bonus tracking
                await JS.InvokeVoidAsync("console.log", $"üé∞ BONUS DEBUG: BonusTriggered={lastSpinResult.BonusTriggered}, TotalBonusesTriggered={lastSpinResult.TotalBonusesTriggered}, BonusLog='{lastSpinResult.BonusLog}'");

                // Parse chosen reel set
                var reelSet = root.GetProperty("chosenReelSet");
                chosenReelSet = new
                {
                    Name = reelSet.GetProperty("name").GetString() ?? "",
                    ExpectedRtp = reelSet.GetProperty("expectedRtp").GetDouble(),
                    EstimatedHitRate = reelSet.GetProperty("estimatedHitRate").GetDouble()
                };

                // Parse winning lines
                var apiWinningLines = new List<ApiWinningLine>();
                var winningLinesArray = root.GetProperty("winningLines");
                await JS.InvokeVoidAsync("console.log", $"Winning lines array count: {winningLinesArray.GetArrayLength()}");
                
                foreach (var line in winningLinesArray.EnumerateArray())
                {
                    await JS.InvokeVoidAsync("console.log", $"Raw winning line JSON: {line.GetRawText()}");
                    
                    try
                    {
                        // Try to parse manually to debug the issue
                        var symbol = line.TryGetProperty("symbol", out var symbolProp) ? symbolProp.GetString() ?? "" : "";
                        var count = line.TryGetProperty("count", out var countProp) ? countProp.GetInt32() : 0;
                        var winAmount = line.TryGetProperty("winAmount", out var winAmountProp) ? winAmountProp.GetDouble() : 0.0;
                        var svgPath = line.TryGetProperty("svgPath", out var svgPathProp) ? svgPathProp.GetString() ?? "" : "";
                        
                        await JS.InvokeVoidAsync("console.log", $"Parsed manually - Symbol: '{symbol}', Count: {count}, WinAmount: {winAmount}, SvgPath: '{svgPath}'");
                        
                                                 var apiLine = new ApiWinningLine
                         {
                             Symbol = symbol,
                             Count = count,
                             WinAmount = winAmount,
                             SvgPath = svgPath,
                             PaylineType = line.TryGetProperty("paylineType", out var paylineTypeProp) ? paylineTypeProp.GetString() ?? "" : "",
                             PaylineIndex = line.TryGetProperty("paylineIndex", out var paylineIndexProp) ? paylineIndexProp.GetInt32() : -1,
                             Positions = new List<Position>(),
                             FullPaylinePath = new List<Position>()
                         };
                        
                                                 // Parse positions
                         if (line.TryGetProperty("positions", out var positionsProp))
                         {
                             foreach (var pos in positionsProp.EnumerateArray())
                             {
                                 var col = pos.TryGetProperty("col", out var colProp) ? colProp.GetInt32() : 0;
                                 var row = pos.TryGetProperty("row", out var rowProp) ? rowProp.GetInt32() : 0;
                                 apiLine.Positions.Add(new Position { Col = col, Row = row });
                             }
                         }
                         
                         // Parse full payline path
                         if (line.TryGetProperty("fullPaylinePath", out var fullPaylinePathProp))
                         {
                             foreach (var pos in fullPaylinePathProp.EnumerateArray())
                             {
                                 var col = pos.TryGetProperty("col", out var colProp) ? colProp.GetInt32() : 0;
                                 var row = pos.TryGetProperty("row", out var rowProp) ? rowProp.GetInt32() : 0;
                                 apiLine.FullPaylinePath.Add(new Position { Col = col, Row = row });
                             }
                         }
                        
                        apiWinningLines.Add(apiLine);
                        await JS.InvokeVoidAsync("console.log", $"Added winning line: Symbol='{apiLine.Symbol}', Count={apiLine.Count}, WinAmount={apiLine.WinAmount}, Positions={apiLine.Positions.Count}, SvgPath='{apiLine.SvgPath}'");
                    }
                    catch (Exception ex)
                    {
                        await JS.InvokeVoidAsync("console.error", $"Error parsing winning line: {ex.Message}");
                    }
                }
                
                await JS.InvokeVoidAsync("console.log", $"Total winning lines processed: {apiWinningLines.Count}");
                ProcessWinningLinesFromApi(apiWinningLines);
                await JS.InvokeVoidAsync("console.log", $"Frontend winning lines: {winningLines.Count}, Winning positions: {winningPositions.Count}");
                
                // Force UI update to show winning lines
                StateHasChanged();

                // Parse stats
                currentRtp = root.GetProperty("rtp").GetDouble();
                currentHitRate = root.GetProperty("hitRate").GetDouble();
                totalSpins++;

                await JS.InvokeVoidAsync("console.log", $"Spin completed - TotalWin: {lastSpinResult?.TotalWin}, RTP: {currentRtp}, HitRate: {currentHitRate}");

                // Update charts
                await UpdateChartsWithNewData();
            }
            else
            {
                var errorContent = await response.Content.ReadAsStringAsync();
                await JS.InvokeVoidAsync("console.error", $"API Error: {response.StatusCode} - {errorContent}");
                await JS.InvokeVoidAsync("alert", "Spin failed. Please try again.");
            }
        }
        catch (Exception ex)
        {
            await JS.InvokeVoidAsync("console.error", "Spin error:", ex.Message);
            await JS.InvokeVoidAsync("alert", "Spin failed. Please try again.");
        }
        finally
        {
            isSpinning = false;
            StateHasChanged();
        }
    }

    private string GetSymbolClass(string symbol)
    {
        return symbol switch
        {
            "SYM0" => "scatter",
            "SYM1" => "wild",
            "SYM2" => "bonus",
            "SYM3" or "SYM4" or "SYM5" or "SYM6" => "high-pay",
            _ => ""
        };
    }

    private async Task InitializeCharts()
    {
        // Get configuration values
        var rtpTarget = Configuration.GetValue<double>("RtpTarget", 0.88);
        var hitRateTarget = Configuration.GetValue<double>("TargetHitRate", 0.35);
        
        // Initialize with some sample data
        rtpLabels = new List<string> { "Start" };
        rtpData = new List<double> { rtpTarget };
        rtpTargetData = new List<double> { rtpTarget };
        hitRateLabels = new List<string> { "Start" };
        hitRateData = new List<double> { hitRateTarget };
        hitRateTargetData = new List<double> { hitRateTarget };

        await RenderCharts();
        
        // Add debug logging
        await JS.InvokeVoidAsync("console.log", "Charts initialization completed");
        await JS.InvokeVoidAsync("console.log", $"Chart.js available: {await JS.InvokeAsync<bool>("eval", "window.Chart !== undefined")}");
    }

    private async Task RenderCharts()
    {
        try
        {
            // Wait a bit to ensure DOM is ready
            await Task.Delay(100);
            
            // RTP Chart
            await JS.InvokeVoidAsync("eval", $@"
                console.log('Initializing RTP Chart...');
                if (window.Chart) {{
                    var canvas = document.getElementById('rtpChartSmall');
                    if (canvas) {{
                        if(window.rtpChartSmallInstance) window.rtpChartSmallInstance.destroy();
                        var ctx = canvas.getContext('2d');
                        window.rtpChartSmallInstance = new Chart(ctx, {{
                            type: 'line',
                            data: {{
                                labels: {ToJsArray(rtpLabels)},
                                datasets: [
                                    {{
                                        label: 'Actual RTP',
                                        data: {ToJsArray(rtpData)},
                                        borderColor: 'blue',
                                        backgroundColor: 'rgba(0,0,255,0.1)',
                                        fill: false
                                    }},
                                    {{
                                        label: 'Target RTP',
                                        data: {ToJsArray(rtpTargetData)},
                                        borderColor: 'red',
                                        backgroundColor: 'rgba(255,0,0,0.1)',
                                        borderDash: [5, 5],
                                        fill: false
                                    }}
                                ]
                            }},
                            options: {{ 
                                responsive: true,
                                maintainAspectRatio: false,
                                elements: {{
                                    point: {{
                                        radius: 0
                                    }},
                                    line: {{
                                        tension: 0.4
                                    }}
                                }},
                                plugins: {{
                                    legend: {{
                                        display: true
                                    }}
                                }}
                            }}
                        }});
                        console.log('RTP Chart initialized successfully');
                    }} else {{
                        console.error('RTP Chart canvas not found');
                    }}
                }} else {{
                    console.error('Chart.js not loaded');
                }}
            ");

            // Hit Rate Chart
            await JS.InvokeVoidAsync("eval", $@"
                console.log('Initializing Hit Rate Chart...');
                if (window.Chart) {{
                    var canvas = document.getElementById('hitRateChartSmall');
                    if (canvas) {{
                        if(window.hitRateChartSmallInstance) window.hitRateChartSmallInstance.destroy();
                        var ctx = canvas.getContext('2d');
                        window.hitRateChartSmallInstance = new Chart(ctx, {{
                            type: 'line',
                            data: {{
                                labels: {ToJsArray(hitRateLabels)},
                                datasets: [
                                    {{
                                        label: 'Actual Hit Rate',
                                        data: {ToJsArray(hitRateData)},
                                        borderColor: 'green',
                                        backgroundColor: 'rgba(0,255,0,0.1)',
                                        fill: false
                                    }},
                                    {{
                                        label: 'Target Hit Rate',
                                        data: {ToJsArray(hitRateTargetData)},
                                        borderColor: 'orange',
                                        backgroundColor: 'rgba(255,165,0,0.1)',
                                        borderDash: [5, 5],
                                        fill: false
                                    }}
                                ]
                            }},
                            options: {{ 
                                responsive: true,
                                maintainAspectRatio: false,
                                elements: {{
                                    point: {{
                                        radius: 0
                                    }},
                                    line: {{
                                        tension: 0.4
                                    }}
                                }},
                                plugins: {{
                                    legend: {{
                                        display: true
                                    }}
                                }}
                            }}
                        }});
                        console.log('Hit Rate Chart initialized successfully');
                    }} else {{
                        console.error('Hit Rate Chart canvas not found');
                    }}
                }} else {{
                    console.error('Chart.js not loaded');
                }}
            ");
        }
        catch (Exception ex)
        {
            await JS.InvokeVoidAsync("console.error", $"Chart initialization error: {ex.Message}");
        }
    }

    private async Task UpdateChartsWithNewData()
    {
        if (!chartsInitialized) return;

        // Get configuration values
        var rtpTarget = Configuration.GetValue<double>("RtpTarget", 0.88);
        var hitRateTarget = Configuration.GetValue<double>("TargetHitRate", 0.35);

        // Add new data points
        rtpLabels.Add($"Spin {totalSpins}");
        hitRateLabels.Add($"Spin {totalSpins}");
        rtpData.Add(currentRtp);
        rtpTargetData.Add(rtpTarget); // Target RTP from configuration
        hitRateData.Add(currentHitRate);
        hitRateTargetData.Add(hitRateTarget); // Target Hit Rate from configuration

        // Update RTP Chart
        await JS.InvokeVoidAsync("eval", $@"
            if (window.rtpChartSmallInstance) {{
                window.rtpChartSmallInstance.data.labels.push('{rtpLabels.Last()}');
                window.rtpChartSmallInstance.data.datasets[0].data.push({rtpData.Last()});
                window.rtpChartSmallInstance.data.datasets[1].data.push({rtpTargetData.Last()});
                window.rtpChartSmallInstance.update('none');
            }}
        ");

        // Update Hit Rate Chart
        await JS.InvokeVoidAsync("eval", $@"
            if (window.hitRateChartSmallInstance) {{
                window.hitRateChartSmallInstance.data.labels.push('{hitRateLabels.Last()}');
                window.hitRateChartSmallInstance.data.datasets[0].data.push({hitRateData.Last()});
                window.hitRateChartSmallInstance.data.datasets[1].data.push({hitRateTargetData.Last()});
                window.hitRateChartSmallInstance.update('none');
            }}
        ");
    }

         private string ToJsArray(IEnumerable<double> data) => "[" + string.Join(",", data) + "]";
     private string ToJsArray(IEnumerable<string> data) => "[" + string.Join(",", data.Select(x => $"'" + x + "'")) + "]";
     
     private string CreateSvgPath(List<Position> positions)
     {
         if (positions == null || positions.Count == 0) return "";
         
         var path = new System.Text.StringBuilder();
         bool first = true;
         
         foreach (var pos in positions)
         {
             // Convert grid position to SVG coordinates
             int x = pos.Col * 100 + 50; // 100px per column, center at 50
             int y = pos.Row * 60 + 30;  // 60px per row, center at 30
             
             if (first)
             {
                 path.Append($"M {x} {y}");
                 first = false;
             }
             else
             {
                 path.Append($" L {x} {y}");
             }
         }
         
         return path.ToString();
     }
     
     private string GetSymbolImageName(string symbol)
     {
         // Convert symbol name (e.g., "SYM0") to image filename (e.g., "sym0.png")
         if (string.IsNullOrEmpty(symbol)) return "sym0.png";
         
         // Extract the number from the symbol name
         if (symbol.StartsWith("SYM", StringComparison.OrdinalIgnoreCase))
         {
             string numberPart = symbol.Substring(3);
             if (int.TryParse(numberPart, out int number))
             {
                 return $"sym{number}.png";
             }
         }
         
         // Fallback to sym0.png if parsing fails
         return "sym0.png";
     }
} 